CREATE DATABASE SQL_SAMPLE_INTERVIEW;

USE SQL_SAMPLE_INTERVIEW;

CREATE TABLE users (
    USER_ID INT PRIMARY KEY,
    USER_NAME VARCHAR(20) NOT NULL,
    USER_STATUS VARCHAR(20) NOT NULL
);

CREATE TABLE logins (
    USER_ID INT,
    LOGIN_TIMESTAMP DATETIME NOT NULL,
    SESSION_ID INT PRIMARY KEY,
    SESSION_SCORE INT,
    FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID)
);

-- Users Table
INSERT INTO USERS VALUES (1, 'Alice', 'Active');
INSERT INTO USERS VALUES (2, 'Bob', 'Inactive');
INSERT INTO USERS VALUES (3, 'Charlie', 'Active');
INSERT INTO USERS  VALUES (4, 'David', 'Active');
INSERT INTO USERS  VALUES (5, 'Eve', 'Inactive');
INSERT INTO USERS  VALUES (6, 'Frank', 'Active');
INSERT INTO USERS  VALUES (7, 'Grace', 'Inactive');
INSERT INTO USERS  VALUES (8, 'Heidi', 'Active');
INSERT INTO USERS VALUES (9, 'Ivan', 'Inactive');
INSERT INTO USERS VALUES (10, 'Judy', 'Active');

-- Logins Table 

INSERT INTO LOGINS  VALUES (1, '2023-07-15 09:30:00', 1001, 85);
INSERT INTO LOGINS VALUES (2, '2023-07-22 10:00:00', 1002, 90);
INSERT INTO LOGINS VALUES (3, '2023-08-10 11:15:00', 1003, 75);
INSERT INTO LOGINS VALUES (4, '2023-08-20 14:00:00', 1004, 88);
INSERT INTO LOGINS  VALUES (5, '2023-09-05 16:45:00', 1005, 82);

INSERT INTO LOGINS  VALUES (6, '2023-10-12 08:30:00', 1006, 77);
INSERT INTO LOGINS  VALUES (7, '2023-11-18 09:00:00', 1007, 81);
INSERT INTO LOGINS VALUES (8, '2023-12-01 10:30:00', 1008, 84);
INSERT INTO LOGINS  VALUES (9, '2023-12-15 13:15:00', 1009, 79);


-- 2024 Q1
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (1, '2024-01-10 07:45:00', 1011, 86);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (2, '2024-01-25 09:30:00', 1012, 89);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (3, '2024-02-05 11:00:00', 1013, 78);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (4, '2024-03-01 14:30:00', 1014, 91);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (5, '2024-03-15 16:00:00', 1015, 83);

INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (6, '2024-04-12 08:00:00', 1016, 80);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (7, '2024-05-18 09:15:00', 1017, 82);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (8, '2024-05-28 10:45:00', 1018, 87);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (9, '2024-06-15 13:30:00', 1019, 76);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-25 15:00:00', 1010, 92);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-26 15:45:00', 1020, 93);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-27 15:00:00', 1021, 92);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-28 15:45:00', 1022, 93);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (1, '2024-01-10 07:45:00', 1101, 86);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (3, '2024-01-25 09:30:00', 1102, 89);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (5, '2024-01-15 11:00:00', 1103, 78);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (2, '2023-11-10 07:45:00', 1201, 82);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (4, '2023-11-25 09:30:00', 1202, 84);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (6, '2023-11-15 11:00:00', 1203, 80);

SELECT * FROM users;
SELECT * FROM logins;

-- Questions
-- 1. Management wants to see all the users that did not login in the past 5 months 
-- return username
-- solution 1
SELECT  DISTINCT u.USER_NAME FROM logins L 
JOIN users u ON
l.USER_ID = u.USER_ID 
WHERE l.USER_ID NOT IN (
SELECT USER_ID FROM logins
WHERE LOGIN_TIMESTAMP > DATEADD(MONTH,-5,(SELECT MAX(LOGIN_TIMESTAMP) FROM logins))
);

-- solution 2
SELECT u.USER_NAME FROM logins L 
JOIN users u ON
l.USER_ID = u.USER_ID 
GROUP BY u.USER_NAME
HAVING MAX(LOGIN_TIMESTAMP)  < DATEADD(MONTH,-5,(SELECT MAX(LOGIN_TIMESTAMP) FROM logins))

--2. For the business units' quarterly analysis, calculate how many users and how many sessions were at each quarter
-- order by quarter from newest to oldest.
-- return: first day of the quarter, user_cnt, session_cnt

SELECT 
	DATETRUNC(QUARTER,MIN(LOGIN_TIMESTAMP)) AS first_day_of_quarter,
	COUNT(DISTINCT USER_ID) AS user_cnt,
	COUNT(SESSION_ID) AS sess_cnt 
FROM logins
GROUP BY DATEPART(QUARTER,LOGIN_TIMESTAMP)
ORDER BY first_day_of_quarter DESC;


--3. Display user id's that Log-in in January 2024  and did not Log-in on November 2023
-- Return: user_id
SELECT DISTINCT USER_ID FROM logins
WHERE MONTH(LOGIN_TIMESTAMP) = '01' AND YEAR(LOGIN_TIMESTAMP) = '2024'
AND USER_ID NOT IN (
SELECT USER_ID FROM logins
WHERE MONTH(LOGIN_TIMESTAMP) = '11' AND YEAR(LOGIN_TIMESTAMP) = '2023'); 


-- 4. Add to the query from 2 the percentage change in sessions from last quarter.
-- return: first day of the quarter, user_cnt, session_cnt,session_prev_cnt,session_percentage_change
WITH CTE AS(
SELECT 
	DATETRUNC(QUARTER,MIN(LOGIN_TIMESTAMP)) AS first_day_of_quarter,
	COUNT(DISTINCT USER_ID) AS user_cnt,
	COUNT(SESSION_ID) AS sess_cnt 
FROM logins
GROUP BY DATEPART(QUARTER,LOGIN_TIMESTAMP))

SELECT *,
	LAG(sess_cnt,1) OVER(ORDER BY first_day_of_quarter) AS sess_prev_cnt,
	ROUND((
	(sess_cnt-(LAG(sess_cnt,1) OVER(ORDER BY first_day_of_quarter)))*100.0
	/(LAG(sess_cnt,1) OVER(ORDER BY first_day_of_quarter))),2)  AS session_percentage_change
FROM CTE;


--5. Display the user that had the highest session score (max) for each day
-- Return: Date, username, score
WITH RankedSessions AS (
    SELECT 
        CAST(L.LOGIN_TIMESTAMP AS DATE) AS Login_Date,
        U.USER_NAME,
        SUM(L.SESSION_SCORE) AS Total_sess_score,
        ROW_NUMBER() OVER (
            PARTITION BY CAST(L.LOGIN_TIMESTAMP AS DATE)
            ORDER BY SUM(L.SESSION_SCORE) DESC
        ) AS rn
    FROM LOGINS L
    JOIN USERS U ON U.USER_ID = L.USER_ID
	GROUP BY CAST(L.LOGIN_TIMESTAMP AS DATE),  U.USER_NAME
)
SELECT Login_Date, USER_NAME, Total_sess_score
FROM RankedSessions
WHERE rn = 1;




-- 6. To identify our best users - Return users that had a session on every single day since their first login
-- (make assuptions if needed). assumption -this data contains details till 28/06/2024
-- Return user id
SELECT 
	USER_ID, 
	MIN(CAST(LOGIN_TIMESTAMP AS DATE)) AS first_login,
	DATEDIFF(DAY,MIN(CAST(LOGIN_TIMESTAMP AS DATE)),'2024-06-28')+1 AS no_of_login_days_required,
	COUNT( DISTINCT CAST(LOGIN_TIMESTAMP AS DATE)) AS no_of_login_days
FROM logins
GROUP BY USER_ID
HAVING DATEDIFF(DAY,MIN(CAST(LOGIN_TIMESTAMP AS DATE)),'2024-06-28')+1 = COUNT( DISTINCT CAST(LOGIN_TIMESTAMP AS DATE)) 


-- 7. On what dates there were no log-in at all?
-- Return: Login-dates -> assumption -this data contains details till 28/06/2024

-- Min: '20223-07-15' & Max: '2024-06-28'
-- Total: 350 dates
-- login_dates: 26 
-- not login_dates = 350 - 26 = 324


WITH CTE AS(
SELECT MIN(CAST(LOGIN_TIMESTAMP AS DATE)) AS date1 FROM logins
UNION ALL
SELECT DATEADD(DAY,1,date1) FROM CTE WHERE date1 < '2024-06-28')

SELECT DISTINCT date1 FROM CTE
WHERE date1 NOT IN
( SELECT DISTINCT CAST(LOGIN_TIMESTAMP AS DATE) FROM logins)
OPTION (MAXRECURSION 500);